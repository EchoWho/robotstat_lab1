import os, sys, pdb, numpy
from scipy import signal as signal
from scipy import stats as stats

class observation_model:
    i = 12345
    sigma = 1 # stdev of gaussian for p_hit (comp1_gauss)
    dmu = 0 # bias; distance from expected signal -- used in gaussian for p_hit (comp1_gauss)
    mu_expon = 0.01 # mean of exponential distribution
    max_rng = [48 , 52]
    # Relative weights of observation model components
    c = []
    c_hit = 1/4
    c_short = 1/4
    c_max = 1/4
    c_rand = 1/4

        # Some sort of map lookup thingy
    def Get_z_expected(x):
        return x

    def Get_p_z_given_x_u(x, u)

        z_exp = Get_z_expected(x)


        # Determine relative weights for each component in the observation model
        # Add in any parameter changes to the distribution based on u, z_expected
        C_hit = c_hit * 1
        C_short = c_short * 1
        C_max = c_max * 1
        C_rand = c_rand * 1
        # Normalize to 1 (probability distribution should integrate to 1)
        sum_Cs = C_hit + C_short + C_max + C_rand
        C_hit = C_hit / sum_Cs
        C_short = C_short / sum_Cs
        C_max = C_max / sum_Cs
        C_rand = C_rand / sum_Cs

        p_hit =  stats.norm.pdf(z_exp, mean=(z_expected + dmu), std=sigma) # comp1_gauss
        p_short = stats.expon.pdf(z_exp, 0.01) # comp2_exp = # Exponential distribution here
        p_max = stats.uniform.pdf(z_exp, lb=max_rng[1], up=max_rng[2] ) # Uniform distribution
        p_rand = stats.uniform.pdf(z_exp, lb=0, up=max_rng[2] # Uniform distribution
        
        p_z_given_x = c_hit * p_hit + c_short * p_short + c_max * p_max + c_rand * p_rand

        return p_z_given_x
        
        

class motion_model:
    i = 12345
    p0 = 1 # uniform
    mu = [0,0]
    Sigma = [[1,0],[0,1]]

    def Get_p_x1_given_x0_u(x0,u)
         mu_x1 = mu + x0 + u
         ellipse = multivariate_normal(mean=mu, cov=Sigma)
         ellipse.pdf(x0)
         # We may need to add a uniform component to this

    

